#!/usr/bin/env python3

import subprocess
import os
import argparse
from openai import OpenAI
from dotenv import load_dotenv

load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def run_git_command(command, check=True):
    try:
        result = subprocess.run(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=check,
            encoding='utf-8'
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"âŒ Erro ao executar: {' '.join(command)}")
        print(f"   {e.stderr.strip()}")
        exit(1)
    except FileNotFoundError:
        print(f"âŒ Comando git nÃ£o encontrado. Verifique se o Git estÃ¡ instalado e no PATH.")
        exit(1)

def get_git_diff():
    run_git_command(["git", "add", "."])
    diff = run_git_command(["git", "diff", "--cached"])
    return diff

def gerar_sugestao_openai(prompt, model="gpt-4o-mini", temperature=0.3):
    try:
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=temperature,
        )
        return response.choices[0].message.content.strip().replace("`", "")
    except Exception as e:
        print(f"âŒ Erro na API OpenAI: {e}")
        exit(1)

def gerar_mensagem_commit(diff, temperature=0.3):
    prompt = (
        "VocÃª Ã© um assistente que gera mensagens de commit no formato conventional commits.\n"
        "Com base no git diff abaixo, identifique a mudanÃ§a MAIS SIGNIFICATIVA e gere uma mensagem de commit curta e clara em inglÃªs sobre ela.\n"
        "Concentre-se no propÃ³sito principal da alteraÃ§Ã£o.\n"
        "Use prefixos como feat, fix, chore, refactor, test, docs, style, perf, ci, build, revert etc.\n"
        "Somente a mensagem, sem explicaÃ§Ãµes ou observaÃ§Ãµes extras.\n"
        "Gere somente UMA mensagem de commit, sem quebra de linha ou formataÃ§Ã£o especial.\n"
        "Nada alem de uma mensagem de commit.\n\n"
        f"Diff:\n{diff}"
    )
    return gerar_sugestao_openai(prompt, temperature=temperature)

def gerar_nome_branch(diff, temperature=0.5):
    prompt = (
        "VocÃª Ã© um assistente que gera nomes de branch Git.\n"
        "Com base no git diff abaixo, identifique a mudanÃ§a MAIS SIGNIFICATIVA e gere um nome de branch curto, descritivo, em inglÃªs sobre ela, "
        "usando hÃ­fens para separar palavras e seguindo o formato 'tipo/descricao-curta'.\n"
        "O nome deve refletir o objetivo principal das alteraÃ§Ãµes.\n"
        "Use prefixos como feat/, fix/, chore/, refactor/, test/, docs/, style/, perf/, ci/, build/, revert/.\n"
        "Exemplos: feat/add-user-login, fix/resolve-payment-bug, chore/update-dependencies.\n"
        "Gere SOMENTE o nome da branch, sem explicaÃ§Ãµes ou observaÃ§Ãµes extras.\n\n"
        f"Diff:\n{diff}"
    )
    return gerar_sugestao_openai(prompt, temperature=temperature)

def interagir_usuario(prompt_pergunta, funcao_geracao, diff):
    if "branch" in prompt_pergunta.lower():
        temperatura_sugerida = 0.5
    else:
        temperatura_sugerida = 0.3

    while True:
        sugestao = funcao_geracao(diff, temperature=temperatura_sugerida)
        print(f"\nğŸ’¬ {prompt_pergunta}:\n{sugestao}")

        resposta = input("    â¡ï¸  Aceita? (s) | ğŸ”„ Outra? (o) | ğŸš« Recusar? (N): ").strip().lower()

        if resposta == "s":
            return sugestao
        elif resposta == "o":
            temperatura_sugerida = min(1.0, temperatura_sugerida + 0.2)
            print(f"â„¹ï¸  Tentando uma sugestÃ£o diferente (temperatura: {temperatura_sugerida:.1f})...")
            continue
        else:
            return None

def main():
    parser = argparse.ArgumentParser(description="Gera commits e branches com IA.")
    parser.add_argument("--branch", "-b", action="store_true", help="Solicita a geraÃ§Ã£o de um nome de branch.")
    args = parser.parse_args()

    if not os.getenv("OPENAI_API_KEY"):
        print("âŒ VariÃ¡vel de ambiente OPENAI_API_KEY nÃ£o configurada.")
        print("   Por favor, defina-a no seu arquivo .env ou no ambiente.")
        exit(1)

    diff = get_git_diff()

    if not diff:
        print("âœ… Nenhuma mudanÃ§a staged encontrada. Nada para commitar.")
        exit(0)

    branch_name = None
    nova_branch = False
    current_branch_original = run_git_command(["git", "rev-parse", "--abbrev-ref", "HEAD"])


    if args.branch:
        branch_name = interagir_usuario("SugestÃ£o de branch", gerar_nome_branch, diff)
        if branch_name:
            if branch_name == current_branch_original:
                print(f"âš ï¸  A sugestÃ£o de branch ('{branch_name}') Ã© a mesma da branch atual. Nenhuma branch nova serÃ¡ criada.")
                nova_branch = False
            else:
                print(f"ğŸŒ¿ Criando e mudando para a branch '{branch_name}'...")
                run_git_command(["git", "checkout", "-b", branch_name], check=False) # check=False to handle existing branch case manually
                current_branch_check = run_git_command(["git", "rev-parse", "--abbrev-ref", "HEAD"])
                if current_branch_check == branch_name:
                    nova_branch = True
                    print(f"âœ… Trocado para nova branch '{branch_name}'.")
                else: # pragma: no cover
                    # This case should ideally be caught by git checkout -b failing if branch exists
                    # or handled if we allowed overwriting. For now, assume it means user stayed.
                    print(f"âš ï¸  NÃ£o foi possÃ­vel criar ou trocar para a branch '{branch_name}'. Verifique se jÃ¡ existe ou se hÃ¡ conflitos.")
                    print(f"   Continuando na branch '{current_branch_original}'.")
                    branch_name = None # Reset branch_name as it wasn't successful
        else:
            print("ğŸš« CriaÃ§Ã£o de branch cancelada. Continuando na branch atual.")

    mensagem_commit = interagir_usuario("SugestÃ£o de commit", gerar_mensagem_commit, diff)

    if mensagem_commit:
        print(f"\nğŸ“ RevisÃ£o do Commit:")
        print(f"   Mensagem: \"{mensagem_commit}\"")
        
        branch_para_commit = run_git_command(["git", "rev-parse", "--abbrev-ref", "HEAD"])
        if nova_branch and branch_name:
            print(f"   Branch: {branch_name} (nova)")
        else:
            print(f"   Branch: {branch_para_commit} (atual)")

        confirmacao = input("\nâœ… Deseja realizar o commit e push? (s/N): ").strip().lower()

        if confirmacao == "s":
            print("ğŸ’¾ Realizando commit...")
            run_git_command(["git", "commit", "-m", mensagem_commit])
            
            branch_para_push = run_git_command(["git", "rev-parse", "--abbrev-ref", "HEAD"])
            print(f"ğŸš€ Realizando push para a branch '{branch_para_push}'...")
            
            if nova_branch and branch_para_push == branch_name :
                run_git_command(["git", "push", "--set-upstream", "origin", branch_para_push])
            else:
                run_git_command(["git", "push", "origin", branch_para_push])
            print("âœ¨ Sucesso!")
        else:
            print("ğŸš« OperaÃ§Ã£o cancelada pelo usuÃ¡rio.")
            # Se uma nova branch foi criada mas o commit/push foi cancelado,
            # perguntar se deseja voltar para a branch original.
            if nova_branch and branch_name != current_branch_original:
                voltar = input(f"â“ VocÃª criou a branch '{branch_name}'. Deseja retornar para a branch original '{current_branch_original}'? (s/N): ").strip().lower()
                if voltar == 's':
                    print(f"â†ªï¸  Retornando para a branch '{current_branch_original}'...")
                    run_git_command(["git", "checkout", current_branch_original])
                    print(f"âœ… Retornou para '{current_branch_original}'.")
                else:
                    print(f"â„¹ï¸  Permanecendo na branch '{branch_name}'.")
    else:
        print("ğŸš« Commit cancelado.")
        if nova_branch and branch_name != current_branch_original:
            voltar = input(f"â“ VocÃª criou a branch '{branch_name}' mas cancelou o commit. Deseja retornar para a branch original '{current_branch_original}'? (s/N): ").strip().lower()
            if voltar == 's':
                print(f"â†ªï¸  Retornando para a branch '{current_branch_original}'...")
                run_git_command(["git", "checkout", current_branch_original])
                print(f"âœ… Retornou para '{current_branch_original}'.")
            else:
                print(f"â„¹ï¸  Permanecendo na branch '{branch_name}'.")


if __name__ == "__main__":
    main()


